"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SOURCE_VERSIONS = exports.SourceSpecDefinition = exports.sourceIdentity = void 0;
const graphql_1 = require("graphql");
const coreSpec_1 = require("./coreSpec");
const definitions_1 = require("../definitions");
const knownCoreFeatures_1 = require("../knownCoreFeatures");
const directiveAndTypeSpecification_1 = require("../directiveAndTypeSpecification");
const error_1 = require("../error");
exports.sourceIdentity = 'https://specs.apollo.dev/source';
class SourceSpecDefinition extends coreSpec_1.FeatureDefinition {
    constructor(version, minimumFederationVersion) {
        super(new coreSpec_1.FeatureUrl(exports.sourceIdentity, 'source', version), minimumFederationVersion);
        this.minimumFederationVersion = minimumFederationVersion;
        this.registerDirective((0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
            name: 'sourceAPI',
            locations: [graphql_1.DirectiveLocation.SCHEMA],
            repeatable: true,
            composes: false,
        }));
        this.registerDirective((0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
            name: 'sourceType',
            locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.INTERFACE],
            repeatable: true,
            composes: false,
        }));
        this.registerDirective((0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
            name: 'sourceField',
            locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
            repeatable: true,
            composes: false,
        }));
    }
    addElementsToSchema(schema) {
        const sourceAPI = this.addDirective(schema, 'sourceAPI').addLocations(graphql_1.DirectiveLocation.SCHEMA);
        sourceAPI.repeatable = true;
        sourceAPI.addArgument('name', new definitions_1.NonNullType(schema.stringType()));
        const HTTPHeaderMapping = schema.addType(new definitions_1.InputObjectType('HTTPHeaderMapping'));
        HTTPHeaderMapping.addField(new definitions_1.InputFieldDefinition('name')).type =
            new definitions_1.NonNullType(schema.stringType());
        HTTPHeaderMapping.addField(new definitions_1.InputFieldDefinition('as')).type =
            schema.stringType();
        HTTPHeaderMapping.addField(new definitions_1.InputFieldDefinition('value')).type =
            schema.stringType();
        const HTTPSourceAPI = schema.addType(new definitions_1.InputObjectType('HTTPSourceAPI'));
        HTTPSourceAPI.addField(new definitions_1.InputFieldDefinition('baseURL')).type =
            new definitions_1.NonNullType(schema.stringType());
        HTTPSourceAPI.addField(new definitions_1.InputFieldDefinition('headers')).type =
            new definitions_1.ListType(new definitions_1.NonNullType(HTTPHeaderMapping));
        sourceAPI.addArgument('http', HTTPSourceAPI);
        const sourceType = this.addDirective(schema, 'sourceType').addLocations(graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.INTERFACE);
        sourceType.repeatable = true;
        sourceType.addArgument('api', new definitions_1.NonNullType(schema.stringType()));
        const URLPathTemplate = this.addScalarType(schema, 'URLPathTemplate');
        const JSONSelection = this.addScalarType(schema, 'JSONSelection');
        const HTTPSourceType = schema.addType(new definitions_1.InputObjectType('HTTPSourceType'));
        HTTPSourceType.addField(new definitions_1.InputFieldDefinition('GET')).type = URLPathTemplate;
        HTTPSourceType.addField(new definitions_1.InputFieldDefinition('POST')).type = URLPathTemplate;
        HTTPSourceType.addField(new definitions_1.InputFieldDefinition('headers')).type =
            new definitions_1.ListType(new definitions_1.NonNullType(HTTPHeaderMapping));
        HTTPSourceType.addField(new definitions_1.InputFieldDefinition('body')).type = JSONSelection;
        sourceType.addArgument('http', HTTPSourceType);
        sourceType.addArgument('selection', new definitions_1.NonNullType(JSONSelection));
        const KeyTypeMap = schema.addType(new definitions_1.InputObjectType('KeyTypeMap'));
        KeyTypeMap.addField(new definitions_1.InputFieldDefinition('key')).type = new definitions_1.NonNullType(schema.stringType());
        KeyTypeMap.addField(new definitions_1.InputFieldDefinition('typeMap')).type =
            this.addScalarType(schema, 'TypenameKeyMap');
        sourceType.addArgument('keyTypeMap', KeyTypeMap);
        const sourceField = this.addDirective(schema, 'sourceField').addLocations(graphql_1.DirectiveLocation.FIELD_DEFINITION);
        sourceField.repeatable = true;
        sourceField.addArgument('api', new definitions_1.NonNullType(schema.stringType()));
        sourceField.addArgument('selection', JSONSelection);
        sourceField.addArgument('keyTypeMap', KeyTypeMap);
        const HTTPSourceField = schema.addType(new definitions_1.InputObjectType('HTTPSourceField'));
        HTTPSourceField.addField(new definitions_1.InputFieldDefinition('GET')).type = URLPathTemplate;
        HTTPSourceField.addField(new definitions_1.InputFieldDefinition('POST')).type = URLPathTemplate;
        HTTPSourceField.addField(new definitions_1.InputFieldDefinition('PUT')).type = URLPathTemplate;
        HTTPSourceField.addField(new definitions_1.InputFieldDefinition('PATCH')).type = URLPathTemplate;
        HTTPSourceField.addField(new definitions_1.InputFieldDefinition('DELETE')).type = URLPathTemplate;
        HTTPSourceField.addField(new definitions_1.InputFieldDefinition('body')).type = JSONSelection;
        HTTPSourceField.addField(new definitions_1.InputFieldDefinition('headers')).type =
            new definitions_1.ListType(new definitions_1.NonNullType(HTTPHeaderMapping));
        sourceField.addArgument('http', HTTPSourceField);
        return [];
    }
    allElementNames() {
        return [
            '@sourceAPI',
            '@sourceType',
            '@sourceField',
        ];
    }
    sourceAPIDirective(schema) {
        return this.directive(schema, 'sourceAPI');
    }
    sourceTypeDirective(schema) {
        return this.directive(schema, 'sourceType');
    }
    sourceFieldDirective(schema) {
        return this.directive(schema, 'sourceField');
    }
    getSourceDirectives(schema, errors) {
        const result = {};
        let federationVersion;
        schema.schemaDefinition.appliedDirectivesOf('link')
            .forEach(linkDirective => {
            const { url, import: imports } = linkDirective.arguments();
            const featureUrl = coreSpec_1.FeatureUrl.maybeParse(url);
            if (imports && featureUrl && featureUrl.identity === exports.sourceIdentity) {
                imports.forEach(nameOrRename => {
                    const originalName = typeof nameOrRename === 'string' ? nameOrRename : nameOrRename.name;
                    const importedName = typeof nameOrRename === 'string' ? nameOrRename : nameOrRename.as || originalName;
                    const importedNameWithoutAt = importedName.replace(/^@/, '');
                    if (originalName === '@sourceAPI') {
                        result.sourceAPI = schema.directive(importedNameWithoutAt);
                    }
                    else if (originalName === '@sourceType') {
                        result.sourceType = schema.directive(importedNameWithoutAt);
                    }
                    else if (originalName === '@sourceField') {
                        result.sourceField = schema.directive(importedNameWithoutAt);
                    }
                });
            }
            if (featureUrl && featureUrl.name === 'federation') {
                federationVersion = featureUrl.version;
            }
        });
        if (result.sourceAPI || result.sourceType || result.sourceField) {
            if (!federationVersion || federationVersion.lt(this.minimumFederationVersion)) {
                errors.push(error_1.ERRORS.SOURCE_FEDERATION_VERSION_REQUIRED.err(`Schemas that @link to ${exports.sourceIdentity} must also @link to federation version ${this.minimumFederationVersion} or later (found ${federationVersion})`));
            }
        }
        return result;
    }
    validateSubgraphSchema(schema) {
        const errors = super.validateSubgraphSchema(schema);
        const { sourceAPI, sourceType, sourceField, } = this.getSourceDirectives(schema, errors);
        if (!(sourceAPI || sourceType || sourceField)) {
            return [];
        }
        const apiNameToProtocol = new Map();
        if (sourceAPI) {
            this.validateSourceAPI(sourceAPI, apiNameToProtocol, errors);
        }
        if (sourceType) {
            this.validateSourceType(sourceType, apiNameToProtocol, errors);
        }
        if (sourceField) {
            this.validateSourceField(sourceField, apiNameToProtocol, errors);
        }
        return errors;
    }
    validateSourceAPI(sourceAPI, apiNameToProtocol, errors) {
        sourceAPI.applications().forEach(application => {
            const { name, ...rest } = application.arguments();
            if (!isValidSourceAPIName(name)) {
                errors.push(error_1.ERRORS.SOURCE_API_NAME_INVALID.err(`${sourceAPI}(name: ${JSON.stringify(name)}) must specify name using only [a-zA-Z0-9-_] characters`, { nodes: application.sourceAST }));
            }
            if (apiNameToProtocol.has(name)) {
                errors.push(error_1.ERRORS.SOURCE_API_NAME_INVALID.err(`${sourceAPI} must specify unique name (${JSON.stringify(name)} reused)`, { nodes: application.sourceAST }));
            }
            let protocol;
            KNOWN_SOURCE_PROTOCOLS.forEach(knownProtocol => {
                if (rest[knownProtocol]) {
                    if (protocol) {
                        errors.push(error_1.ERRORS.SOURCE_API_PROTOCOL_INVALID.err(`${sourceAPI} must specify only one of ${KNOWN_SOURCE_PROTOCOLS.join(', ')} but specified both ${protocol} and ${knownProtocol}`, { nodes: application.sourceAST }));
                    }
                    protocol = knownProtocol;
                }
            });
            if (protocol) {
                apiNameToProtocol.set(name, protocol);
                const protocolValue = rest[protocol];
                if (protocolValue && protocol === HTTP_PROTOCOL) {
                    const { baseURL, headers } = protocolValue;
                    try {
                        new URL(baseURL);
                    }
                    catch (e) {
                        errors.push(error_1.ERRORS.SOURCE_API_HTTP_BASE_URL_INVALID.err(`${sourceAPI} http.baseURL ${JSON.stringify(baseURL)} must be valid URL (error: ${e.message})`, { nodes: application.sourceAST }));
                    }
                    validateHTTPHeaders(headers, errors, sourceAPI.name);
                }
            }
            else {
                errors.push(error_1.ERRORS.SOURCE_API_PROTOCOL_INVALID.err(`${sourceAPI} must specify one protocol from the set {${KNOWN_SOURCE_PROTOCOLS.join(',')}}`, { nodes: application.sourceAST }));
            }
        });
    }
    validateSourceType(sourceType, apiNameToProtocol, errors) {
        sourceType.applications().forEach(application => {
            var _a;
            const { api, selection, ...rest } = application.arguments();
            if (!api || !apiNameToProtocol.has(api)) {
                errors.push(error_1.ERRORS.SOURCE_TYPE_API_ERROR.err(`${sourceType} specifies unknown api ${api}`, { nodes: application.sourceAST }));
            }
            const expectedProtocol = apiNameToProtocol.get(api) || HTTP_PROTOCOL;
            const protocolValue = expectedProtocol && rest[expectedProtocol];
            if (expectedProtocol && !protocolValue) {
                errors.push(error_1.ERRORS.SOURCE_TYPE_PROTOCOL_INVALID.err(`${sourceType} must specify same ${expectedProtocol} argument as corresponding @sourceAPI for api ${api}`, { nodes: application.sourceAST }));
            }
            if (protocolValue && expectedProtocol === HTTP_PROTOCOL) {
                const { GET, POST, headers, body } = protocolValue;
                if ([GET, POST].filter(Boolean).length !== 1) {
                    errors.push(error_1.ERRORS.SOURCE_TYPE_HTTP_METHOD_INVALID.err(`${sourceType} must specify exactly one of http.GET or http.POST`, { nodes: application.sourceAST }));
                }
                else {
                    const urlPathTemplate = (GET || POST);
                    try {
                        parseURLPathTemplate(urlPathTemplate);
                    }
                    catch (e) {
                        errors.push(error_1.ERRORS.SOURCE_TYPE_HTTP_PATH_INVALID.err(`${sourceType} http.GET or http.POST must be valid URL path template (error: ${e.message})`));
                    }
                }
                validateHTTPHeaders(headers, errors, sourceType.name);
                if (body) {
                    if (GET) {
                        errors.push(error_1.ERRORS.SOURCE_TYPE_HTTP_BODY_INVALID.err(`${sourceType} http.GET cannot specify http.body`, { nodes: application.sourceAST }));
                    }
                    try {
                        parseJSONSelection(body);
                    }
                    catch (e) {
                        errors.push(error_1.ERRORS.SOURCE_TYPE_HTTP_BODY_INVALID.err(`${sourceType} http.body not valid JSONSelection (error: ${e.message})`, { nodes: application.sourceAST }));
                    }
                }
            }
            const ast = application.parent.sourceAST;
            switch (ast === null || ast === void 0 ? void 0 : ast.kind) {
                case "ObjectTypeDefinition":
                case "InterfaceTypeDefinition":
                    if (!((_a = ast.directives) === null || _a === void 0 ? void 0 : _a.some(directive => directive.name.value === "key"))) {
                        errors.push(error_1.ERRORS.SOURCE_TYPE_ON_NON_OBJECT_OR_NON_ENTITY.err(`${sourceType} must be applied to an entity type that also has a @key directive`, { nodes: application.sourceAST }));
                    }
                    try {
                        parseJSONSelection(selection);
                    }
                    catch (e) {
                        errors.push(error_1.ERRORS.SOURCE_TYPE_SELECTION_INVALID.err(`${sourceType} selection not valid JSONSelection (error: ${e.message})`, { nodes: application.sourceAST }));
                    }
                    break;
                default:
                    errors.push(error_1.ERRORS.SOURCE_TYPE_ON_NON_OBJECT_OR_NON_ENTITY.err(`${sourceType} must be applied to object or interface type`, { nodes: application.sourceAST }));
            }
        });
    }
    validateSourceField(sourceField, apiNameToProtocol, errors) {
        sourceField.applications().forEach(application => {
            var _a, _b, _c;
            const { api, selection, ...rest } = application.arguments();
            if (!api || !apiNameToProtocol.has(api)) {
                errors.push(error_1.ERRORS.SOURCE_FIELD_API_ERROR.err(`${sourceField} specifies unknown api ${api}`, { nodes: application.sourceAST }));
            }
            const expectedProtocol = apiNameToProtocol.get(api) || HTTP_PROTOCOL;
            const protocolValue = expectedProtocol && rest[expectedProtocol];
            if (protocolValue && expectedProtocol === HTTP_PROTOCOL) {
                const { GET, POST, PUT, PATCH, DELETE, headers, body, } = protocolValue;
                const usedMethods = [GET, POST, PUT, PATCH, DELETE].filter(Boolean);
                if (usedMethods.length > 1) {
                    errors.push(error_1.ERRORS.SOURCE_FIELD_HTTP_METHOD_INVALID.err(`${sourceField} allows at most one of http.{GET,POST,PUT,PATCH,DELETE}`));
                }
                else if (usedMethods.length === 1) {
                    const urlPathTemplate = usedMethods[0];
                    try {
                        parseURLPathTemplate(urlPathTemplate);
                    }
                    catch (e) {
                        errors.push(error_1.ERRORS.SOURCE_FIELD_HTTP_PATH_INVALID.err(`${sourceField} http.{GET,POST,PUT,PATCH,DELETE} must be valid URL path template (error: ${e.message})`));
                    }
                }
                validateHTTPHeaders(headers, errors, sourceField.name);
                if (body) {
                    if (GET) {
                        errors.push(error_1.ERRORS.SOURCE_FIELD_HTTP_BODY_INVALID.err(`${sourceField} http.GET cannot specify http.body`, { nodes: application.sourceAST }));
                    }
                    else if (DELETE) {
                        errors.push(error_1.ERRORS.SOURCE_FIELD_HTTP_BODY_INVALID.err(`${sourceField} http.DELETE cannot specify http.body`, { nodes: application.sourceAST }));
                    }
                    try {
                        parseJSONSelection(body);
                    }
                    catch (e) {
                        errors.push(error_1.ERRORS.SOURCE_FIELD_HTTP_BODY_INVALID.err(`${sourceField} http.body not valid JSONSelection (error: ${e.message})`, { nodes: application.sourceAST }));
                    }
                }
            }
            if (selection) {
                try {
                    parseJSONSelection(selection);
                }
                catch (e) {
                    errors.push(error_1.ERRORS.SOURCE_FIELD_SELECTION_INVALID.err(`${sourceField} selection not valid JSONSelection (error: ${e.message})`, { nodes: application.sourceAST }));
                }
            }
            const fieldParent = application.parent;
            if (((_a = fieldParent.sourceAST) === null || _a === void 0 ? void 0 : _a.kind) !== graphql_1.Kind.FIELD_DEFINITION) {
                errors.push(error_1.ERRORS.SOURCE_FIELD_NOT_ON_ROOT_OR_ENTITY_FIELD.err(`${sourceField} must be applied to field`, { nodes: application.sourceAST }));
            }
            else {
                const typeGrandparent = fieldParent.parent;
                if (((_b = typeGrandparent.sourceAST) === null || _b === void 0 ? void 0 : _b.kind) !== graphql_1.Kind.OBJECT_TYPE_DEFINITION) {
                    errors.push(error_1.ERRORS.SOURCE_FIELD_NOT_ON_ROOT_OR_ENTITY_FIELD.err(`${sourceField} must be applied to field of object type`, { nodes: application.sourceAST }));
                }
                else {
                    const typeGrandparentName = (_c = typeGrandparent.sourceAST) === null || _c === void 0 ? void 0 : _c.name.value;
                    if (typeGrandparentName !== "Query" &&
                        typeGrandparentName !== "Mutation" &&
                        typeGrandparent.appliedDirectivesOf("key").length === 0) {
                        errors.push(error_1.ERRORS.SOURCE_FIELD_NOT_ON_ROOT_OR_ENTITY_FIELD.err(`${sourceField} must be applied to root Query or Mutation field or field of entity type`, { nodes: application.sourceAST }));
                    }
                }
            }
        });
    }
}
exports.SourceSpecDefinition = SourceSpecDefinition;
function isValidSourceAPIName(name) {
    return /^[a-z-_][a-z0-9-_]*$/i.test(name);
}
function isValidHTTPHeaderName(name) {
    return /^[a-zA-Z0-9-_]+$/.test(name);
}
function validateHTTPHeaders(headers, errors, directiveName) {
    if (!directiveName.startsWith('@')) {
        directiveName = '@' + directiveName;
    }
    if (headers) {
        headers.forEach(({ name, as, value }, i) => {
            if (!isValidHTTPHeaderName(name)) {
                errors.push(error_1.ERRORS.SOURCE_HTTP_HEADERS_INVALID.err(`${directiveName} header ${JSON.stringify(headers[i])} specifies invalid name`));
            }
            if (as && !isValidHTTPHeaderName(as)) {
                errors.push(error_1.ERRORS.SOURCE_HTTP_HEADERS_INVALID.err(`${directiveName} header ${JSON.stringify(headers[i])} specifies invalid 'as' name`));
            }
            if (as && value) {
                errors.push(error_1.ERRORS.SOURCE_HTTP_HEADERS_INVALID.err(`${directiveName} header ${JSON.stringify(headers[i])} should specify at most one of 'as' or 'value'`));
            }
        });
    }
}
function parseJSONSelection(_selection) {
}
function parseURLPathTemplate(_template) {
}
const HTTP_PROTOCOL = "http";
const KNOWN_SOURCE_PROTOCOLS = [
    HTTP_PROTOCOL,
];
exports.SOURCE_VERSIONS = new coreSpec_1.FeatureDefinitions(exports.sourceIdentity)
    .add(new SourceSpecDefinition(new coreSpec_1.FeatureVersion(0, 1), new coreSpec_1.FeatureVersion(2, 7)));
(0, knownCoreFeatures_1.registerKnownFeature)(exports.SOURCE_VERSIONS);
//# sourceMappingURL=sourceSpec.js.map